/**
 * Workstation Chrome Extension - Popup Script
 * Handles UI interactions and communication with background script
 * v1.1 Features: History, Save/Load, Settings, Status Polling
 */

// DOM elements - Execute Tab
const recordBtn = document.getElementById('recordBtn');
const stopBtn = document.getElementById('stopBtn');
const clearBtn = document.getElementById('clearBtn');
const executeBtn = document.getElementById('executeBtn');
const saveBtn = document.getElementById('saveBtn');
const promptTextarea = document.getElementById('prompt');
const statusDiv = document.getElementById('status');
const resultDiv = document.getElementById('result');
const recordingIndicator = document.getElementById('recordingIndicator');

// DOM elements - History Tab
const historyList = document.getElementById('historyList');
const clearHistoryBtn = document.getElementById('clearHistoryBtn');

// DOM elements - Settings Tab
const backendUrlInput = document.getElementById('backendUrl');
const pollIntervalInput = document.getElementById('pollInterval');
const autoRetryCheckbox = document.getElementById('autoRetry');
const saveSettingsBtn = document.getElementById('saveSettingsBtn');

// DOM elements - Tabs
const tabButtons = document.querySelectorAll('.tab');
const tabContents = document.querySelectorAll('.tab-content');

// State
let isRecording = false;
let currentExecutionId = null;
let pollingInterval = null;
let settings = {
  backendUrl: 'http://localhost:3000',
  pollInterval: 2000,
  autoRetry: true
};

// Initialize
document.addEventListener('DOMContentLoaded', async () => {
  await loadSettings();
  await loadRecordedActions();
  await loadHistory();
  setupTabNavigation();
});

/**
 * Tab Navigation
 */
function setupTabNavigation() {
  tabButtons.forEach(button => {
    button.addEventListener('click', () => {
      const tabName = button.dataset.tab;
      switchTab(tabName);
    });
  });
}

function switchTab(tabName) {
  // Update active tab button
  tabButtons.forEach(btn => btn.classList.remove('active'));
  document.querySelector(`[data-tab="${tabName}"]`).classList.add('active');
  
  // Update active tab content
  tabContents.forEach(content => content.classList.remove('active'));
  document.getElementById(`${tabName}Tab`).classList.add('active');
  
  // Refresh data if switching to history
  if (tabName === 'history') {
    loadHistory();
  }
}

/**
 * Settings Management
 */
async function loadSettings() {
  const stored = await chrome.storage.local.get(['settings']);
  if (stored.settings) {
    settings = { ...settings, ...stored.settings };
  }
  
  // Update UI
  backendUrlInput.value = settings.backendUrl;
  pollIntervalInput.value = settings.pollInterval;
  autoRetryCheckbox.checked = settings.autoRetry;
}

saveSettingsBtn.addEventListener('click', async () => {
  settings = {
    backendUrl: backendUrlInput.value.trim(),
    pollInterval: parseInt(pollIntervalInput.value),
    autoRetry: autoRetryCheckbox.checked
  };
  
  await chrome.storage.local.set({ settings });
  showStatus('âœ… Settings saved successfully!', 'success');
  
  // Notify background script of settings change
  chrome.runtime.sendMessage({ action: 'updateSettings', settings });
});

/**
 * Workflow History Management
 */
async function loadHistory() {
  const stored = await chrome.storage.local.get(['workflowHistory']);
  const history = stored.workflowHistory || [];
  
  if (history.length === 0) {
    historyList.innerHTML = '<div class="history-empty">No workflow history yet</div>';
    return;
  }
  
  // Sort by timestamp descending (newest first)
  history.sort((a, b) => b.timestamp - a.timestamp);
  
  historyList.innerHTML = history.map(item => `
    <div class="history-item" data-id="${item.id}">
      <div class="history-item-header">
        <div class="history-item-title">${escapeHtml(item.description)}</div>
        <span class="history-item-status ${item.status}">${item.status}</span>
      </div>
      <div class="history-item-time">${formatTimestamp(item.timestamp)}</div>
    </div>
  `).join('');
  
  // Add click handlers
  document.querySelectorAll('.history-item').forEach(item => {
    item.addEventListener('click', () => {
      const id = item.dataset.id;
      loadWorkflowFromHistory(id, history);
    });
  });
}

function loadWorkflowFromHistory(id, history) {
  const workflow = history.find(w => w.id === id);
  if (workflow) {
    promptTextarea.value = workflow.description;
    switchTab('execute');
    showStatus('Workflow loaded from history', 'info');
  }
}

clearHistoryBtn.addEventListener('click', async () => {
  if (confirm('Clear all workflow history?')) {
    await chrome.storage.local.set({ workflowHistory: [] });
    await loadHistory();
    showStatus('History cleared', 'info');
  }
});

/**
 * Save Workflow
 */
saveBtn.addEventListener('click', async () => {
  const description = promptTextarea.value.trim();
  if (!description) {
    showStatus('Please enter a workflow description first', 'error');
    return;
  }
  
  const workflow = {
    id: generateId(),
    description,
    timestamp: Date.now(),
    status: 'saved'
  };
  
  // Add to history
  const stored = await chrome.storage.local.get(['workflowHistory']);
  const history = stored.workflowHistory || [];
  history.push(workflow);
  await chrome.storage.local.set({ workflowHistory: history });
  
  showStatus('âœ… Workflow saved successfully!', 'success');
});
  isRecording = true;
  recordBtn.style.display = 'none';
  stopBtn.style.display = 'flex';
  recordingIndicator.classList.add('active');
  
  // Send message to content script to start recording
  const [tab] = await chrome.tabs.query({ active: true, currentWindow: true });
  chrome.tabs.sendMessage(tab.id, { action: 'startRecording' });
  
  showStatus('Recording started. Interact with the page...', 'info');
});

// Stop button click
stopBtn.addEventListener('click', async () => {
  isRecording = false;
  stopBtn.style.display = 'none';
  recordBtn.style.display = 'flex';
  recordingIndicator.classList.remove('active');
  
  // Send message to content script to stop recording
  const [tab] = await chrome.tabs.query({ active: true, currentWindow: true });
  chrome.tabs.sendMessage(tab.id, { action: 'stopRecording' });
  
  // Load and display recorded actions
  await loadRecordedActions();
  showStatus('Recording stopped. Actions captured.', 'success');
});

// Clear button click
clearBtn.addEventListener('click', async () => {
  chrome.runtime.sendMessage({ action: 'clearRecordedActions' }, (response) => {
    if (response && response.success) {
      promptTextarea.value = '';
      resultDiv.classList.remove('visible');
      showStatus('Recorded actions cleared.', 'info');
    }
  });
});

// Execute button click
executeBtn.addEventListener('click', async () => {
  const prompt = promptTextarea.value.trim();
  
  if (!prompt) {
    showStatus('Please enter a workflow description.', 'error');
    return;
  }
  
  // Disable button during execution
  executeBtn.disabled = true;
  executeBtn.textContent = 'â³ Executing...';
  showStatus('Executing workflow...', 'info');
  
  try {
    // Send workflow to background script
    const workflow = {
      description: prompt,
      actions: [] // Could include recorded actions here
    };
    
    chrome.runtime.sendMessage(
      { action: 'executeWorkflow', workflow },
      (response) => {
        executeBtn.disabled = false;
        executeBtn.textContent = 'ðŸš€ Execute Workflow';
        
        if (response && response.success) {
          showStatus('âœ… Workflow executed successfully!', 'success');
          displayResult(response.data);
        } else {
          const errorMsg = response?.error || 'Unknown error occurred';
          showStatus(`âŒ Execution failed: ${errorMsg}`, 'error');
          displayResult({ error: errorMsg });
        }
      }
    );
  } catch (error) {
    executeBtn.disabled = false;
    executeBtn.textContent = 'ðŸš€ Execute Workflow';
    showStatus(`âŒ Error: ${error.message}`, 'error');
    displayResult({ error: error.message });
  }
});

/**
 * Load recorded actions from storage
 */
async function loadRecordedActions() {
  chrome.runtime.sendMessage({ action: 'getRecordedActions' }, (actions) => {
    if (actions && actions.length > 0) {
      // Display count of recorded actions
      showStatus(`${actions.length} actions recorded`, 'info');
    }
  });
}

/**
 * Show status message
 * @param {string} message - Status message
 * @param {string} type - Status type (success, error, info)
 */
function showStatus(message, type = 'info') {
  statusDiv.textContent = message;
  statusDiv.className = `status visible ${type}`;
  
  // Auto-hide info messages after 3 seconds
  if (type === 'info') {
    setTimeout(() => {
      statusDiv.classList.remove('visible');
    }, 3000);
  }
}

/**
 * Display execution result
 * @param {Object} data - Result data
 */
function displayResult(data) {
  const pre = document.createElement('pre');
  pre.textContent = JSON.stringify(data, null, 2);
  
  resultDiv.innerHTML = '';
  resultDiv.appendChild(pre);
  resultDiv.classList.add('visible');
}
